plugins {
    id 'java'
    id 'com.gradleup.shadow' version '9.0.0'
    id 'maven-publish'
    id 'com.vanniktech.maven.publish'
    id 'me.champeau.gradle.japicmp' version '0.4.3'
}

def libraryName = "jfr-shell"
def component_version = project.hasProperty("jafar_version") ? project.jafar_version : rootProject.version

repositories {
    mavenCentral()
    mavenLocal()
    maven {
        url "https://oss.sonatype.org/content/repositories/snapshots/"
    }
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(25)
    }
}

// Create baseline configuration for japicmp
configurations {
    japicmpBaseline
}

dependencies {
    implementation project(':parser')
    implementation project(':tools')

    // Backend plugins available for testing (discovered via ServiceLoader)
    testRuntimeOnly project(':jfr-shell-jafar')
    testRuntimeOnly project(':jfr-shell-jdk')

    // Command line parsing
    implementation 'info.picocli:picocli:4.7.5'

    // JLine for better terminal handling
    implementation 'org.jline:jline-terminal:3.21.0'
    implementation 'org.jline:jline-reader:3.21.0'

    // Utilities
    implementation 'org.slf4j:slf4j-api:2.0.5'
    implementation 'org.slf4j:slf4j-simple:2.0.5'

    // JSON processing for plugin metadata
    implementation 'com.google.code.gson:gson:2.10.1'

    // Maven Resolver for plugin downloads
    implementation 'org.apache.maven:maven-resolver-provider:3.9.9'
    implementation 'org.apache.maven.resolver:maven-resolver-api:1.9.18'
    implementation 'org.apache.maven.resolver:maven-resolver-impl:1.9.18'
    implementation 'org.apache.maven.resolver:maven-resolver-connector-basic:1.9.18'
    implementation 'org.apache.maven.resolver:maven-resolver-transport-http:1.9.18'
    implementation 'org.apache.httpcomponents:httpclient:4.5.14'

    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.2'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.10.2'
    testImplementation 'org.mockito:mockito-core:5.12.0'

    // jqwik for property-based testing
    testImplementation 'net.jqwik:jqwik:1.8.2'
    testRuntimeOnly 'net.jqwik:jqwik-engine:1.8.2'

    // Baseline for API compatibility checking
    japicmpBaseline "io.btrace:jafar-shell:0.9.0@jar"
}

// API compatibility checking for backend plugin API
task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask) {
    group = 'Verification'
    description = 'Check binary compatibility of backend plugin API'

    // Only check if not a SNAPSHOT and not first release with plugin API
    onlyIf { !version.toString().contains('SNAPSHOT') && version != '0.10.0' }

    oldClasspath.from(configurations.japicmpBaseline)
    newClasspath.from(sourceSets.main.output)
    newArchives.from(jar)

    // Package to check (backend plugin API)
    packageIncludes = ['io.jafar.shell.backend.*']

    // Fail build on breaking changes (unless major version bump)
    failOnModification = true
    failOnSourceIncompatibility = true

    // Allow additions (new methods with defaults, new capabilities)
    compatibilityChangeExcludes = ['METHOD_NEW_DEFAULT']

    onlyBinaryIncompatibleModified = false
    onlyModified = true

    // HTML report
    htmlOutputFile = file("$buildDir/reports/japicmp.html")

    // Text report for CI
    txtOutputFile = file("$buildDir/reports/japicmp.txt")
}

// Run japicmp as part of check
tasks.named('check') {
    dependsOn japicmp
}

test {
    useJUnitPlatform {
        includeEngines 'jqwik', 'junit-jupiter'
    }
    // Enable Byte Buddy experimental support for Java 25 when used by Mockito
    systemProperty 'net.bytebuddy.experimental', 'true'

    // jqwik configuration
    systemProperty 'jqwik.tries.default', '1000'
    systemProperty 'jqwik.shrinking.mode', 'FULL'
}

processResources {
    from(rootProject.file('jfr-shell-plugins.json'))
}

shadowJar {
    group 'Build'
    archiveBaseName = libraryName
    archiveVersion = component_version
    // Keep classifier so shadow JAR doesn't replace regular jar for inter-project deps
    archiveClassifier.set('all')

    // Merge service files for ServiceLoader discovery
    mergeServiceFiles()

    // Relocate dependencies to avoid conflicts with plugin JARs
    relocate 'org.apache.maven.resolver', 'io.jafar.shaded.resolver'
    relocate 'org.apache.http', 'io.jafar.shaded.http'
    relocate 'com.google.gson', 'io.jafar.shaded.gson'

    // Ensure main class is set
    manifest {
        attributes 'Main-Class': 'io.jafar.shell.Main'
    }
}

// Create standalone jlinked distribution
tasks.register('jlinkDist') {
    group 'Distribution'
    description 'Create a jlinked standalone distribution with custom JRE'

    dependsOn shadowJar

    def outputDir = file("${buildDir}/jlink")
    def jreDir = file("${outputDir}/jre")
    def binDir = file("${outputDir}/bin")
    def libDir = file("${outputDir}/lib")

    outputs.dir(outputDir)

    doLast {
        // Clean output directory
        project.delete(outputDir)
        project.mkdir(outputDir)
        project.mkdir(binDir)
        project.mkdir(libDir)

        // Find JDK with jmods - prefer Java 25 to match compilation target
        def javaHome = null
        def jmodsDir = null

        // First try Java 25 EA (matches compilation target)
        def java25EA = System.getProperty("user.home") + "/.sdkman/candidates/java/25.ea.33-open"
        def java25EAJmods = new File("${java25EA}/jmods")
        if (java25EAJmods.exists()) {
            javaHome = java25EA
            jmodsDir = java25EAJmods
            logger.lifecycle("Using Java 25 EA for jlink (matches compilation target)")
        } else {
            // Fallback to current Java home
            javaHome = System.getProperty("java.home")
            jmodsDir = new File("${javaHome}/jmods")
            if (!jmodsDir.exists()) {
                throw new GradleException("Cannot find JDK with jmods directory. Tried: ${java25EA} and ${javaHome}")
            }
            logger.warn("Using ${javaHome} for jlink - may have version mismatch with compiled classes")
        }

        logger.lifecycle("Using JDK: ${javaHome}")
        logger.lifecycle("Creating custom JRE with jlink...")

        // Run jlink to create custom JRE
        def jlinkCmd = [
            "${javaHome}/bin/jlink",
            '--module-path', jmodsDir.absolutePath,
            '--add-modules', 'java.base,java.logging,java.management,jdk.unsupported,jdk.crypto.ec',
            '--strip-debug',
            '--compress', '2',
            '--no-header-files',
            '--no-man-pages',
            '--output', jreDir.absolutePath
        ]
        def proc = jlinkCmd.execute()
        proc.waitFor()
        if (proc.exitValue() != 0) {
            throw new GradleException("jlink failed: ${proc.errorStream.text}")
        }

        logger.lifecycle("Custom JRE created at: ${jreDir}")

        // Copy shadow jar
        project.copy {
            from(shadowJar.archiveFile)
            into(libDir)
            rename { "${libraryName}.jar" }
        }

        // Create launcher script for Unix/Mac
        def launcherScript = new File("${binDir}/jfr-shell")
        launcherScript.text = """#!/bin/sh
# JFR Shell launcher script

SCRIPT_DIR="\$(cd "\$(dirname "\$0")" && pwd)"
JFR_HOME="\$(dirname "\$SCRIPT_DIR")"
JAVA_HOME="\$JFR_HOME/jre"

exec "\$JAVA_HOME/bin/java" -jar "\$JFR_HOME/lib/${libraryName}.jar" "\$@"
"""
        launcherScript.setExecutable(true)

        // Create launcher script for Windows
        def launcherBat = new File("${binDir}/jfr-shell.bat")
        launcherBat.text = """@echo off
rem JFR Shell launcher script

setlocal

set SCRIPT_DIR=%~dp0
set JFR_HOME=%SCRIPT_DIR%..
set JAVA_HOME=%JFR_HOME%\\jre

"%JAVA_HOME%\\bin\\java" -jar "%JFR_HOME%\\lib\\${libraryName}.jar" %*
"""

        logger.lifecycle("Standalone distribution created at: ${outputDir}")
        logger.lifecycle("Run: ${binDir}/jfr-shell")
    }
}

// Create zip archive of the jlinked distribution
tasks.register('jlinkZip', Zip) {
    group 'Distribution'
    description 'Create a zip archive of the jlinked distribution'

    dependsOn jlinkDist

    from file("${buildDir}/jlink")
    archiveBaseName = libraryName
    archiveVersion = component_version
    archiveClassifier = 'standalone'
    destinationDirectory = file("${buildDir}/distributions")

    doLast {
        logger.lifecycle("Standalone zip created: ${archiveFile.get().asFile}")
    }
}

// Create sources and javadoc JARs (required for Maven Central)
tasks.register('sourcesJar', Jar) {
    from sourceSets.main.allJava
    archiveBaseName.set(libraryName)
    archiveClassifier.set("sources")
    archiveVersion.set(component_version)
}

// Configure javadoc to be lenient (jfr-shell has some javadoc issues to fix)
javadoc {
    options.addStringOption('Xdoclint:none', '-quiet')
    failOnError = false
}

tasks.register('javadocJar', Jar) {
    dependsOn javadoc
    from javadoc.destinationDir
    archiveBaseName.set(libraryName)
    archiveClassifier.set("javadoc")
    archiveVersion.set(component_version)
}

group = 'io.btrace'
version = component_version
description = 'Interactive CLI for exploring and analyzing Java Flight Recorder files'

// Override artifact name for Maven publishing
mavenPublishing {
    coordinates('io.btrace', 'jafar-shell', version.toString())
}

// Override publication to use shadow JAR instead of regular JAR
afterEvaluate {
    publishing {
        publications {
            maven(MavenPublication) {
                // Remove the regular jar artifact added by vanniktech plugin
                artifacts.removeIf { it.classifier == null && it.extension == 'jar' && !it.file.name.contains('-all') }
                // Add shadow JAR as main artifact
                artifact(shadowJar) {
                    classifier = ''  // Publish without classifier
                }
            }
        }
    }
}

// Disable Gradle module metadata for jfr-shell (it's a distribution, not a library)
tasks.withType(GenerateModuleMetadata).configureEach {
    enabled = false
}
