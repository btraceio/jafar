plugins {
    id 'java'
    id 'com.gradleup.shadow' version '8.3.6'
    id 'maven-publish'
    id 'com.vanniktech.maven.publish'
}

def libraryName = "jfr-shell"
def component_version = project.hasProperty("jafar_version") ? project.jafar_version : rootProject.version

repositories {
    mavenCentral()
    mavenLocal()
    maven {
        url "https://oss.sonatype.org/content/repositories/snapshots/"
    }
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

dependencies {
    implementation project(':parser')
    implementation project(':tools')

    // Command line parsing
    implementation 'info.picocli:picocli:4.7.5'

    // JLine for better terminal handling
    implementation 'org.jline:jline-terminal:3.21.0'
    implementation 'org.jline:jline-reader:3.21.0'

    // Utilities
    implementation 'org.slf4j:slf4j-api:2.0.5'
    implementation 'org.slf4j:slf4j-simple:2.0.5'

    // LLM integration - LangChain4j
    implementation 'dev.langchain4j:langchain4j:0.36.2'
    implementation 'dev.langchain4j:langchain4j-ollama:0.36.2'
    implementation 'dev.langchain4j:langchain4j-open-ai:0.36.2'
    implementation 'dev.langchain4j:langchain4j-anthropic:0.36.2'

    // JSON parsing
    implementation 'com.google.code.gson:gson:2.10.1'

    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.2'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.10.2'
    testImplementation 'org.mockito:mockito-core:5.12.0'

    // jqwik for property-based testing
    testImplementation 'net.jqwik:jqwik:1.8.2'
    testRuntimeOnly 'net.jqwik:jqwik-engine:1.8.2'
}

test {
    useJUnitPlatform {
        includeEngines 'jqwik', 'junit-jupiter'
    }
    // Enable Byte Buddy experimental support for Java 25 when used by Mockito
    systemProperty 'net.bytebuddy.experimental', 'true'

    // jqwik configuration
    systemProperty 'jqwik.tries.default', '1000'
    systemProperty 'jqwik.shrinking.mode', 'FULL'

    // Pass through system properties for LLM integration tests
    if (System.getProperty('test.llm.enabled')) {
        systemProperty 'test.llm.enabled', System.getProperty('test.llm.enabled')
    }
}

// LLM Integration Tests
tasks.register('testLLMIntegration', Test) {
    group 'Verification'
    description 'Run LLM integration tests (requires Ollama with llama3.1:8b)'

    dependsOn testClasses
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath

    useJUnitPlatform {
        includeEngines 'junit-jupiter'
    }

    systemProperty 'net.bytebuddy.experimental', 'true'
    systemProperty 'test.llm.enabled', 'true'

    include '**/ImprovedPromptsIntegrationTest.class'

    testLogging {
        events 'passed', 'skipped', 'failed', 'standard_out', 'standard_error'
        showStandardStreams = true
    }
}

// LLM Prompt Tuning Task
tasks.register('tunePrompts', JavaExec) {
    group 'Verification'
    description 'Run LLM prompt tuning tests to optimize query translation'

    classpath = sourceSets.test.runtimeClasspath
    mainClass = 'io.jafar.shell.llm.tuning.PromptTunerMain'

    // Enable Byte Buddy experimental support for Java 25
    systemProperty 'net.bytebuddy.experimental', 'true'

    args = [
        '--test-suite', 'src/test/resources/llm-tuning/test-suite.json',
        '--variants', 'src/test/resources/llm-tuning/variants.json',
        '--recording', 'src/test/resources/sample.jfr',
        '--output', 'build/reports/prompt-tuning'
    ]
}

shadowJar {
    group 'Build'
    archiveBaseName = libraryName
    archiveVersion = component_version
    archiveClassifier.set('')

    // Ensure main class is set
    manifest {
        attributes 'Main-Class': 'io.jafar.shell.Main'
    }
}

// Create standalone jlinked distribution
tasks.register('jlinkDist') {
    group 'Distribution'
    description 'Create a jlinked standalone distribution with custom JRE'

    dependsOn shadowJar

    def outputDir = file("${buildDir}/jlink")
    def jreDir = file("${outputDir}/jre")
    def binDir = file("${outputDir}/bin")
    def libDir = file("${outputDir}/lib")

    outputs.dir(outputDir)

    def javaToolchains = project.extensions.getByType(JavaToolchainService)

    doLast {
        // Clean output directory
        project.delete(outputDir)
        project.mkdir(outputDir)
        project.mkdir(binDir)
        project.mkdir(libDir)

        // Use the configured Java toolchain
        def javaToolchain = project.extensions.getByType(JavaPluginExtension).toolchain
        def javaLauncher = javaToolchains.launcherFor(javaToolchain).get()
        def javaHome = javaLauncher.metadata.installationPath.asFile.absolutePath
        def jmodsDir = new File("${javaHome}/jmods")

        // Some JDK distributions (e.g., Temurin ARM64) don't ship with jmods
        // Fall back to any available Java 25+ JDK with jmods
        if (!jmodsDir.exists()) {
            logger.warn("Toolchain JDK at ${javaHome} does not have jmods directory")
            logger.lifecycle("Searching for alternative JDK with jmods...")

            def sdkmanDir = new File(System.getProperty("user.home"), ".sdkman/candidates/java")
            if (sdkmanDir.exists()) {
                def candidates = sdkmanDir.listFiles()
                    .findAll { it.isDirectory() && it.name.matches("25\\..*") && new File(it, "jmods").exists() }
                    .sort { a, b ->
                        // Prefer non-EA versions
                        def aIsEA = a.name.contains(".ea.")
                        def bIsEA = b.name.contains(".ea.")
                        if (aIsEA != bIsEA) return aIsEA ? 1 : -1
                        // Then prefer oracle over other vendors
                        def aIsOracle = a.name.contains("-oracle")
                        def bIsOracle = b.name.contains("-oracle")
                        if (aIsOracle != bIsOracle) return aIsOracle ? -1 : 1
                        // Finally sort by version descending
                        return b.name <=> a.name
                    }

                if (!candidates.isEmpty()) {
                    javaHome = candidates[0].absolutePath
                    jmodsDir = new File("${javaHome}/jmods")
                    logger.lifecycle("Found alternative JDK with jmods: ${javaHome}")
                } else {
                    throw new GradleException("No Java 25+ JDK with jmods directory found. Please install a JDK that includes jmods (e.g., Oracle OpenJDK or Zulu).")
                }
            } else {
                throw new GradleException("JDK at ${javaHome} does not have jmods directory and no alternatives found.")
            }
        } else {
            logger.lifecycle("Using JDK from toolchain: ${javaHome}")
        }
        logger.lifecycle("Creating custom JRE with jlink...")

        // Run jlink to create custom JRE
        def jlinkCmd = [
            "${javaHome}/bin/jlink",
            '--module-path', jmodsDir.absolutePath,
            '--add-modules', 'java.base,java.logging,java.management,java.net.http,jdk.unsupported,jdk.crypto.ec',
            '--strip-debug',
            '--compress', '2',
            '--no-header-files',
            '--no-man-pages',
            '--output', jreDir.absolutePath
        ]
        def proc = jlinkCmd.execute()
        proc.waitFor()
        if (proc.exitValue() != 0) {
            throw new GradleException("jlink failed: ${proc.errorStream.text}")
        }

        logger.lifecycle("Custom JRE created at: ${jreDir}")

        // Copy shadow jar
        project.copy {
            from(shadowJar.archiveFile)
            into(libDir)
            rename { "${libraryName}.jar" }
        }

        // Create launcher script for Unix/Mac
        def launcherScript = new File("${binDir}/jfr-shell")
        launcherScript.text = """#!/bin/sh
# JFR Shell launcher script

SCRIPT_DIR="\$(cd "\$(dirname "\$0")" && pwd)"
JFR_HOME="\$(dirname "\$SCRIPT_DIR")"
JAVA_HOME="\$JFR_HOME/jre"

exec "\$JAVA_HOME/bin/java" -jar "\$JFR_HOME/lib/${libraryName}.jar" "\$@"
"""
        launcherScript.setExecutable(true)

        // Create launcher script for Windows
        def launcherBat = new File("${binDir}/jfr-shell.bat")
        launcherBat.text = """@echo off
rem JFR Shell launcher script

setlocal

set SCRIPT_DIR=%~dp0
set JFR_HOME=%SCRIPT_DIR%..
set JAVA_HOME=%JFR_HOME%\\jre

"%JAVA_HOME%\\bin\\java" -jar "%JFR_HOME%\\lib\\${libraryName}.jar" %*
"""

        logger.lifecycle("Standalone distribution created at: ${outputDir}")
        logger.lifecycle("Run: ${binDir}/jfr-shell")
    }
}

// Create zip archive of the jlinked distribution
tasks.register('jlinkZip', Zip) {
    group 'Distribution'
    description 'Create a zip archive of the jlinked distribution'

    dependsOn jlinkDist

    from file("${buildDir}/jlink")
    archiveBaseName = libraryName
    archiveVersion = component_version
    archiveClassifier = 'standalone'
    destinationDirectory = file("${buildDir}/distributions")

    doLast {
        logger.lifecycle("Standalone zip created: ${archiveFile.get().asFile}")
    }
}

// Create sources and javadoc JARs (required for Maven Central)
tasks.register('sourcesJar', Jar) {
    from sourceSets.main.allJava
    archiveBaseName.set(libraryName)
    archiveClassifier.set("sources")
    archiveVersion.set(component_version)
}

// Configure javadoc to be lenient (jfr-shell has some javadoc issues to fix)
javadoc {
    options.addStringOption('Xdoclint:none', '-quiet')
    failOnError = false
}

tasks.register('javadocJar', Jar) {
    dependsOn javadoc
    from javadoc.destinationDir
    archiveBaseName.set(libraryName)
    archiveClassifier.set("javadoc")
    archiveVersion.set(component_version)
}

group = 'io.btrace'
version = component_version
description = 'Interactive CLI for exploring and analyzing Java Flight Recorder files'

// Override artifact name for Maven publishing
mavenPublishing {
    coordinates('io.btrace', 'jafar-shell', version.toString())
}

// Override publication to use shadow JAR instead of regular JAR
afterEvaluate {
    publishing {
        publications {
            maven(MavenPublication) {
                // Remove default JAR artifacts
                artifacts.clear()
                // Use shadow JAR as main artifact
                artifact(shadowJar) {
                    classifier = ''
                }
                artifact(sourcesJar)
                artifact(javadocJar)
            }
        }
    }
}
