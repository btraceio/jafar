EVENT TYPE SELECTION GUIDE

This guide helps select the correct JFR event types for common analysis tasks.

*** CRITICAL: ALWAYS CHECK "CURRENT SESSION" CONTEXT FIRST ***

The CURRENT SESSION section above lists which profiling events are actually present
in this recording. You MUST use ONLY the event types listed as present.

DO NOT assume jdk.ExecutionSample exists - use the event types shown in CURRENT SESSION!

=== CPU PROFILING & EXECUTION ANALYSIS ===

When users ask about CPU usage, hot methods, thread activity, or profiling:

STEP 1: Check CURRENT SESSION "Profiling events present" section above
STEP 2: Use ONLY the CPU profiling events listed as present

Possible CPU profiling event types:
- jdk.ExecutionSample - Standard JDK profiling samples
- datadog.ExecutionSample - Datadog profiler samples (richer fields)
- jdk.NativeMethodSample - For native code profiling
- jdk.CPUTimeSample - Explicit CPU time tracking (rare)

IMPORTANT: Different profilers may emit different event types:
- OpenJDK/Oracle JDK recordings: jdk.ExecutionSample
- Datadog profiled applications: datadog.ExecutionSample
- Both may be present in the same recording!

Query patterns:
- Single profiler: events/jdk.ExecutionSample OR events/datadog.ExecutionSample
- Multiple profilers: events/(jdk.ExecutionSample|datadog.ExecutionSample)
- Detect available: metadata/[name ~ '.*ExecutionSample']

Examples (assuming CURRENT SESSION shows jdk.ExecutionSample is present):
Q: "which methods use the most CPU?"
A: {"query": "events/jdk.ExecutionSample/stackTrace/frames/0/method/type/name | groupBy(value) | top(10, by=count)", ...}

Examples (assuming CURRENT SESSION shows datadog.ExecutionSample is present):
Q: "which methods use the most CPU?"
A: {"query": "events/datadog.ExecutionSample/stackTrace/frames/0/method/type/name | groupBy(value) | top(10, by=count)", ...}

Q: "top threads by CPU time" (use whichever ExecutionSample type is present)
A: {"query": "events/datadog.ExecutionSample | groupBy(sampledThread/javaName) | top(10, by=count)", ...}

=== THREAD ANALYSIS ===

Thread states and activity:
- jdk.ThreadStart / jdk.ThreadEnd - Thread lifecycle
- jdk.ThreadPark - Thread parking/waiting
- jdk.ThreadSleep - Thread sleeping
- jdk.JavaMonitorWait / jdk.JavaMonitorEnter - Lock contention

CPU time per thread:
- Use ExecutionSample events grouped by thread:
  events/jdk.ExecutionSample | groupBy(sampledThread/javaName) | top(10, by=count)

Thread CPU load (if available):
- jdk.ThreadCPULoad - Periodic CPU load measurements

=== MEMORY & ALLOCATION ANALYSIS ===

Allocation profiling:
- jdk.ObjectAllocationSample - Sampled allocations (most efficient)
- jdk.ObjectAllocationInNewTLAB - TLAB allocations
- jdk.ObjectAllocationOutsideTLAB - Large allocations
- datadog.ObjectSample - Datadog allocation profiler

Old objects / Heap profiling:

STEP 1: Check CURRENT SESSION "Profiling events present" section for heap profiling
STEP 2: Use ONLY the heap profiling events listed as present

Possible heap profiling event types:
- jdk.OldObjectSample - Long-lived objects (standard JDK heap profiling)
- datadog.HeapLiveObject - Datadog heap profiler (alternative/additional)

IMPORTANT: Different profilers may emit different heap events:
- OpenJDK/Oracle JDK recordings: jdk.OldObjectSample
- Datadog profiled applications: datadog.HeapLiveObject
- Both may be present in the same recording!

Query patterns for heap analysis:
- Single profiler: events/jdk.OldObjectSample OR events/datadog.HeapLiveObject
- Multiple profilers: events/(jdk.OldObjectSample|datadog.HeapLiveObject)
- Detect available: metadata/[name ~ '.*(OldObjectSample|HeapLiveObject)']

Examples (assuming CURRENT SESSION shows jdk.OldObjectSample is present):
Q: "which objects are consuming the most heap memory?"
A: {"query": "events/jdk.OldObjectSample | groupBy(type/name, agg=sum, value=totalSize) | top(10, by=sum)", ...}

Examples (assuming CURRENT SESSION shows datadog.HeapLiveObject is present):
Q: "which objects are consuming the most heap memory?"
A: {"query": "events/datadog.HeapLiveObject | groupBy(type/name, agg=sum, value=totalSize) | top(10, by=sum)", ...}

=== I/O & NETWORK ===

File operations:
- jdk.FileRead / jdk.FileWrite - File I/O with duration and bytes
- jdk.FileForce - File sync operations

Network:
- jdk.SocketRead / jdk.SocketWrite - Network I/O

=== GARBAGE COLLECTION ===

GC events:
- jdk.GarbageCollection - All GC events
- jdk.YoungGarbageCollection - Young gen GC
- jdk.OldGarbageCollection - Old gen GC
- jdk.G1GarbageCollection - G1 specific

GC phases:
- jdk.GCPhasePause - Stop-the-world pause phases
- jdk.GCPhaseConcurrent - Concurrent phases

=== COMPILATION & OPTIMIZATION ===

JIT compilation:
- jdk.Compilation - Method compilation events
- jdk.CompilationFailure - Failed compilations
- jdk.Deoptimization - Method deoptimizations

=== VIRTUAL THREADS (Java 21+) ===

Virtual thread operations:
- jdk.VirtualThreadStart / jdk.VirtualThreadEnd
- jdk.VirtualThreadPinned - Carrier thread pinning

Important: VirtualThreadPinned has no stack trace!
To find pinning methods, correlate with ExecutionSample:
  events/jdk.ExecutionSample | decorateByTime(jdk.VirtualThreadPinned, fields=duration)

=== COMMON MISTAKES ===

❌ WRONG: Using jdk.MethodSample (doesn't exist)
✓ CORRECT: Use jdk.ExecutionSample

❌ WRONG: Assuming only jdk.* events exist
✓ CORRECT: Check for datadog.*, io.*, custom profiler events

❌ WRONG: events/ExecutionSample (missing namespace)
✓ CORRECT: events/jdk.ExecutionSample or events/(jdk.ExecutionSample|datadog.ExecutionSample)

❌ WRONG: Querying VirtualThreadPinned for stack traces
✓ CORRECT: Decorate ExecutionSample with VirtualThreadPinned events

=== MULTI-PROFILER RECORDINGS ===

Some recordings contain events from multiple profilers:

CPU Profiling:
- jdk.ExecutionSample (JDK built-in)
- datadog.ExecutionSample (Datadog profiler)
- Custom profiler events

Heap Profiling:
- jdk.OldObjectSample (JDK built-in)
- datadog.HeapLiveObject (Datadog profiler)

For CPU queries, ALWAYS:
1. Check what profiling events exist: metadata/[name ~ '.*ExecutionSample']
2. Use multi-type query if multiple found: events/(jdk.ExecutionSample|datadog.ExecutionSample)
3. Or query each separately and explain differences

For heap/memory queries, ALWAYS:
1. Check what heap profiling events exist: metadata/[name ~ '.*(OldObjectSample|HeapLiveObject)']
2. Use multi-type query if multiple found: events/(jdk.OldObjectSample|datadog.HeapLiveObject)
3. Or query each separately and explain differences

Datadog profiler events typically include additional fields:
- ExecutionSample: spanId, localRootSpanId (distributed tracing), weight, mode
- HeapLiveObject: May have different field names/structure than OldObjectSample

=== WHEN IN DOUBT ===

If the user asks about CPU/profiling/hot-spots:
1. FIRST: Check "CURRENT SESSION" section above to see which CPU profiling events are present
2. Use ONLY the event type(s) shown as present (e.g., if it shows "datadog.ExecutionSample", use that, NOT jdk.ExecutionSample)
3. Explain in "explanation" field which profiler is being used
4. If NONE are present, explain that CPU profiling data is not available

If the user asks about heap/memory/objects:
1. FIRST: Check "CURRENT SESSION" section above to see which heap profiling events are present
2. Use ONLY the event type(s) shown as present
3. Explain in "explanation" field which profiler is being used
4. If NONE are present, explain that heap profiling data is not available
