EVENT TYPE SELECTION GUIDE

This guide helps select the correct JFR event types for common analysis tasks.

=== CPU PROFILING & EXECUTION ANALYSIS ===

When users ask about CPU usage, hot methods, thread activity, or profiling:

ALWAYS check for these event types (in order of preference):
1. jdk.ExecutionSample - Standard JDK profiling samples (most common)
2. datadog.ExecutionSample - Datadog profiler samples (if present)
3. jdk.NativeMethodSample - For native code profiling
4. jdk.CPUTimeSample - Explicit CPU time tracking (rare, but check)

IMPORTANT: Different profilers may emit different event types:
- OpenJDK/Oracle JDK recordings: jdk.ExecutionSample
- Datadog profiled applications: datadog.ExecutionSample (richer fields)
- Both may be present in the same recording!

Query patterns:
- Single profiler: events/jdk.ExecutionSample
- Multiple profilers: events/(jdk.ExecutionSample|datadog.ExecutionSample)
- Detect available: metadata/[name ~ '.*ExecutionSample']

Examples:
Q: "which methods use the most CPU?"
A: {"query": "events/jdk.ExecutionSample/stackTrace/frames/0/method/type/name | groupBy(value) | top(10, by=count)", ...}

Q: "top threads by CPU time"
A: {"query": "events/jdk.ExecutionSample | groupBy(sampledThread/javaName) | top(10, by=count)", ...}

Q: "CPU profile"
BEST: First check which ExecutionSample types exist, then query them
A: {"query": "metadata/[name ~ '.*ExecutionSample']", "explanation": "Check which profiling event types are available", ...}

=== THREAD ANALYSIS ===

Thread states and activity:
- jdk.ThreadStart / jdk.ThreadEnd - Thread lifecycle
- jdk.ThreadPark - Thread parking/waiting
- jdk.ThreadSleep - Thread sleeping
- jdk.JavaMonitorWait / jdk.JavaMonitorEnter - Lock contention

CPU time per thread:
- Use ExecutionSample events grouped by thread:
  events/jdk.ExecutionSample | groupBy(sampledThread/javaName) | top(10, by=count)

Thread CPU load (if available):
- jdk.ThreadCPULoad - Periodic CPU load measurements

=== MEMORY & ALLOCATION ANALYSIS ===

Allocation profiling:
- jdk.ObjectAllocationSample - Sampled allocations (most efficient)
- jdk.ObjectAllocationInNewTLAB - TLAB allocations
- jdk.ObjectAllocationOutsideTLAB - Large allocations
- datadog.ObjectSample - Datadog allocation profiler

Old objects / Heap profiling:
- jdk.OldObjectSample - Long-lived objects (standard JDK heap profiling)
- datadog.HeapLiveObject - Datadog heap profiler (alternative/additional)

IMPORTANT: Different profilers may emit different heap events:
- OpenJDK/Oracle JDK recordings: jdk.OldObjectSample
- Datadog profiled applications: datadog.HeapLiveObject
- Both may be present in the same recording!

Query patterns for heap analysis:
- Single profiler: events/jdk.OldObjectSample
- Multiple profilers: events/(jdk.OldObjectSample|datadog.HeapLiveObject)
- Detect available: metadata/[name ~ '.*(OldObjectSample|HeapLiveObject)']

Examples:
Q: "which objects are consuming the most heap memory?"
A: {"query": "events/jdk.OldObjectSample | groupBy(type/name, agg=sum, value=totalSize) | top(10, by=sum)", ...}

Q: "largest heap objects"
BEST: First check which heap profiling events exist, then query them
A: {"query": "metadata/[name ~ '.*(OldObjectSample|HeapLiveObject)']", "explanation": "Check which heap profiling event types are available", ...}

=== I/O & NETWORK ===

File operations:
- jdk.FileRead / jdk.FileWrite - File I/O with duration and bytes
- jdk.FileForce - File sync operations

Network:
- jdk.SocketRead / jdk.SocketWrite - Network I/O

=== GARBAGE COLLECTION ===

GC events:
- jdk.GarbageCollection - All GC events
- jdk.YoungGarbageCollection - Young gen GC
- jdk.OldGarbageCollection - Old gen GC
- jdk.G1GarbageCollection - G1 specific

GC phases:
- jdk.GCPhasePause - Stop-the-world pause phases
- jdk.GCPhaseConcurrent - Concurrent phases

=== COMPILATION & OPTIMIZATION ===

JIT compilation:
- jdk.Compilation - Method compilation events
- jdk.CompilationFailure - Failed compilations
- jdk.Deoptimization - Method deoptimizations

=== VIRTUAL THREADS (Java 21+) ===

Virtual thread operations:
- jdk.VirtualThreadStart / jdk.VirtualThreadEnd
- jdk.VirtualThreadPinned - Carrier thread pinning

Important: VirtualThreadPinned has no stack trace!
To find pinning methods, correlate with ExecutionSample:
  events/jdk.ExecutionSample | decorateByTime(jdk.VirtualThreadPinned, fields=duration)

=== COMMON MISTAKES ===

❌ WRONG: Using jdk.MethodSample (doesn't exist)
✓ CORRECT: Use jdk.ExecutionSample

❌ WRONG: Assuming only jdk.* events exist
✓ CORRECT: Check for datadog.*, io.*, custom profiler events

❌ WRONG: events/ExecutionSample (missing namespace)
✓ CORRECT: events/jdk.ExecutionSample or events/(jdk.ExecutionSample|datadog.ExecutionSample)

❌ WRONG: Querying VirtualThreadPinned for stack traces
✓ CORRECT: Decorate ExecutionSample with VirtualThreadPinned events

=== MULTI-PROFILER RECORDINGS ===

Some recordings contain events from multiple profilers:

CPU Profiling:
- jdk.ExecutionSample (JDK built-in)
- datadog.ExecutionSample (Datadog profiler)
- Custom profiler events

Heap Profiling:
- jdk.OldObjectSample (JDK built-in)
- datadog.HeapLiveObject (Datadog profiler)

For CPU queries, ALWAYS:
1. Check what profiling events exist: metadata/[name ~ '.*ExecutionSample']
2. Use multi-type query if multiple found: events/(jdk.ExecutionSample|datadog.ExecutionSample)
3. Or query each separately and explain differences

For heap/memory queries, ALWAYS:
1. Check what heap profiling events exist: metadata/[name ~ '.*(OldObjectSample|HeapLiveObject)']
2. Use multi-type query if multiple found: events/(jdk.OldObjectSample|datadog.HeapLiveObject)
3. Or query each separately and explain differences

Datadog profiler events typically include additional fields:
- ExecutionSample: spanId, localRootSpanId (distributed tracing), weight, mode
- HeapLiveObject: May have different field names/structure than OldObjectSample

=== WHEN IN DOUBT ===

If the user asks about CPU/profiling/hot-spots without specifying:
1. Query: metadata/[name ~ '.*ExecutionSample']
2. Check result to see which profilers are active
3. Generate query using available event type(s)
4. Explain in "explanation" field which profiler(s) are being used

If the user asks about heap/memory/objects without specifying:
1. Query: metadata/[name ~ '.*(OldObjectSample|HeapLiveObject)']
2. Check result to see which heap profilers are active
3. Generate query using available event type(s)
4. Explain in "explanation" field which profiler(s) are being used
