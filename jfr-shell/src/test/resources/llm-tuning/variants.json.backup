{
  "variants": [
    {
      "id": "baseline",
      "description": "Current production prompt",
      "modifications": {}
    },
    {
      "id": "targeted-examples",
      "description": "Add specific examples for allocation and contention patterns",
      "modifications": {
        "customExamples": "CORRECT EXAMPLES:\n\nQ: \"which threads allocated the most memory?\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | groupBy(eventThread/javaName, agg=sum, value=bytes) | top(10, by=sum)\", \"explanation\": \"Groups allocation events by thread and sums the bytes allocated\", \"confidence\": 0.95}\n\nQ: \"top allocating classes\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | groupBy(objectClass/name, agg=sum, value=weight) | top(10, by=sum)\", \"explanation\": \"Groups allocations by class name and sums the allocation weight\", \"confidence\": 0.95}\n\nQ: \"show file reads over 1MB\"\nA: {\"query\": \"events/jdk.FileRead[bytes>1048576]\", \"explanation\": \"Filters file read events to those larger than 1MB\", \"confidence\": 0.98}\n\nQ: \"count GC events\"\nA: {\"query\": \"events/jdk.GarbageCollection | count()\", \"explanation\": \"Counts total garbage collection events\", \"confidence\": 0.98}\n\nQ: \"average GC pause time\"\nA: {\"query\": \"events/jdk.GarbageCollection | stats(duration)\", \"explanation\": \"Calculates statistics for GC pause durations\", \"confidence\": 0.95}\n\nQ: \"top 10 hottest methods\"\nA: {\"query\": \"events/jdk.ExecutionSample/stackTrace/frames/0/method/type/name | groupBy(value) | top(10, by=count)\", \"explanation\": \"Projects to class name from top stack frame, groups by value, shows top 10\", \"confidence\": 0.90}\n\nQ: \"which monitors have the most contention\"\nA: {\"query\": \"events/jdk.JavaMonitorEnter | groupBy(monitorClass/name) | top(10, by=count)\", \"explanation\": \"Groups monitor enter events by monitor class and shows top 10\", \"confidence\": 0.95}\n\nQ: \"top threads by execution samples\"\nA: {\"query\": \"events/jdk.ExecutionSample | groupBy(sampledThread/javaName) | top(10, by=count)\", \"explanation\": \"Groups execution samples by thread name\", \"confidence\": 0.95}\n\nINCORRECT EXAMPLES (DO NOT DO THIS):\n\nQ: \"top allocating classes\"\nWRONG: {\"query\": \"events/jdk.ObjectAllocationSample | groupBy(eventThread/javaClass) | top(10, by=sum)\", ...}\nWHY WRONG: Using eventThread/javaClass instead of objectClass/name - wrong field path for classes\nCORRECT: {\"query\": \"events/jdk.ObjectAllocationSample | groupBy(objectClass/name, agg=sum, value=weight) | top(10, by=sum)\", ...}\n\nQ: \"which monitors have the most contention\"\nWRONG: {\"query\": \"events/jdk.LockContended | groupBy(lockOwner/javaName) | top(10, by=count)\", ...}\nWHY WRONG: Using jdk.LockContended instead of jdk.JavaMonitorEnter - wrong event type\nCORRECT: {\"query\": \"events/jdk.JavaMonitorEnter | groupBy(monitorClass/name) | top(10, by=count)\", ...}\n\nQ: \"top methods\"\nWRONG: {\"query\": \"events/jdk.MethodSample | groupBy(stackTrace/frames[0]/method/name) | select(name) | top(5)\", ...}\nWHY WRONG: (1) jdk.MethodSample doesn't exist (2) frames[0] should be frames/0 (3) select() not supported\nCORRECT: {\"query\": \"events/jdk.ExecutionSample/stackTrace/frames/0/method/type/name | groupBy(value) | top(5, by=count)\", ...}"
      }
    },
    {
      "id": "expanded-examples",
      "description": "Add examples for network I/O, exceptions, class loading, and field precision",
      "modifications": {
        "customExamples": "CORRECT EXAMPLES:\n\nQ: \"top allocating classes\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | groupBy(objectClass/name, agg=sum, value=weight) | top(10, by=sum)\", \"explanation\": \"Groups allocations by class name and sums weight\", \"confidence\": 0.95}\n\nQ: \"which monitors have the most contention\"\nA: {\"query\": \"events/jdk.JavaMonitorEnter | groupBy(monitorClass/name) | top(10, by=count)\", \"explanation\": \"Groups monitor enter events by monitor class\", \"confidence\": 0.95}\n\nQ: \"show network read events\"\nA: {\"query\": \"events/jdk.SocketRead\", \"explanation\": \"Selects all socket read events\", \"confidence\": 0.98}\n\nQ: \"network reads larger than 1KB\"\nA: {\"query\": \"events/jdk.SocketRead[bytesRead>1024]\", \"explanation\": \"Filters socket reads by bytesRead field\", \"confidence\": 0.95}\n\nQ: \"file writes over 5MB\"\nA: {\"query\": \"events/jdk.FileWrite[bytesWritten>5242880]\", \"explanation\": \"Filters file writes by bytesWritten field\", \"confidence\": 0.95}\n\nQ: \"count exceptions by type\"\nA: {\"query\": \"events/jdk.JavaExceptionThrow | groupBy(thrownClass/name)\", \"explanation\": \"Groups exception throw events by exception class\", \"confidence\": 0.95}\n\nQ: \"which classes took longest to load\"\nA: {\"query\": \"events/jdk.ClassLoad | groupBy(loadedClass/name, agg=max, value=duration) | top(10, by=max)\", \"explanation\": \"Groups class loads by class name with max duration aggregation\", \"confidence\": 0.95}\n\nQ: \"threads with longest park times\"\nA: {\"query\": \"events/jdk.ThreadPark | groupBy(eventThread/javaName, agg=sum, value=duration) | top(10, by=sum)\", \"explanation\": \"Groups thread park events by thread and sums duration\", \"confidence\": 0.95}\n\nQ: \"slow compilations over 1 second\"\nA: {\"query\": \"events/jdk.Compilation[duration>1000000000]\", \"explanation\": \"Filters compilation events longer than 1 second (1 billion nanoseconds)\", \"confidence\": 0.95}\n\nQ: \"statistics on object allocation sizes\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | stats(weight)\", \"explanation\": \"Computes statistics on allocation weight field\", \"confidence\": 0.95}\n\nQ: \"network traffic by remote address\"\nA: {\"query\": \"events/jdk.SocketRead | groupBy(address, agg=sum, value=bytesRead)\", \"explanation\": \"Groups socket reads by address and sums bytes\", \"confidence\": 0.95}\n\nQ: \"GC events in young generation longer than 50ms\"\nA: {\"query\": \"events/jdk.GarbageCollection[name=~\\\".*Young.*\\\"][duration>50000000]\", \"explanation\": \"Filters GC events with regex name match and duration threshold\", \"confidence\": 0.90}\n\nINCORRECT EXAMPLES (DO NOT DO THIS):\n\nQ: \"show network read events\"\nWRONG: {\"query\": \"events/jdk.FileRead\", ...}\nWHY WRONG: Using jdk.FileRead for network events - should use jdk.SocketRead\nCORRECT: {\"query\": \"events/jdk.SocketRead\", ...}\n\nQ: \"file writes over 5MB\"\nWRONG: {\"query\": \"events/jdk.FileWrite[bytes>5242880]\", ...}\nWHY WRONG: FileWrite uses bytesWritten field, not bytes\nCORRECT: {\"query\": \"events/jdk.FileWrite[bytesWritten>5242880]\", ...}\n\nQ: \"count exceptions by type\"\nWRONG: {\"query\": \"events/jdk.ExceptionStatistics | groupBy(type)\", ...}\nWHY WRONG: Using jdk.ExceptionStatistics instead of jdk.JavaExceptionThrow\nCORRECT: {\"query\": \"events/jdk.JavaExceptionThrow | groupBy(thrownClass/name)\", ...}\n\nQ: \"slow compilations over 1 second\"\nWRONG: {\"query\": \"events/jdk.Compilation | filter(duration>1000000000)\", ...}\nWHY WRONG: Using filter() operator which doesn't exist - use [] for filtering\nCORRECT: {\"query\": \"events/jdk.Compilation[duration>1000000000]\", ...}\n\nQ: \"which classes took longest to load\"\nWRONG: {\"query\": \"events/jdk.ClassLoad | groupBy(className) | stats(duration)\", ...}\nWHY WRONG: Using stats instead of max aggregation + top, and wrong field path\nCORRECT: {\"query\": \"events/jdk.ClassLoad | groupBy(loadedClass/name, agg=max, value=duration) | top(10, by=max)\", ...}\n\nKEY RULES:\n1. Network events use jdk.SocketRead/jdk.SocketWrite with bytesRead/bytesWritten fields\n2. File events use jdk.FileRead/jdk.FileWrite where FileRead uses 'bytes' but FileWrite uses 'bytesWritten'\n3. Exception tracking uses jdk.JavaExceptionThrow with thrownClass/name field\n4. Thread parking uses jdk.ThreadPark (not jdk.JavaThreadPark)\n5. Class loading uses jdk.ClassLoad with loadedClass/name field\n6. Filtering uses [] syntax, never filter() operator\n7. For 'longest' or 'slowest' queries, use agg=max with top(N, by=max)\n8. For direct statistics without grouping, use stats(field) operator\n9. Regex filters use syntax: [field=~\\\"pattern\\\"]\n10. Multiple filters are chained: [filter1][filter2]"
      }
    },
    {
      "id": "precision-focused",
      "description": "Laser-focused examples for the 4 remaining failures: ExecutionSample patterns, thread field precision, bytes vs weight, regex filters",
      "modifications": {
        "customExamples": "CRITICAL PRECISION RULES - READ CAREFULLY:\n\n1. EXECUTION SAMPLES: Always use jdk.ExecutionSample (NOT jdk.MethodSample which doesn't exist)\n2. THREAD FIELDS: ExecutionSample uses 'sampledThread', allocations use 'eventThread'\n3. MEMORY VS WEIGHT: Use 'bytes' for memory size, 'weight' for allocation pressure\n4. REGEX FILTERS: Use [field=~\\\"pattern\\\"] and chain multiple filters [filter1][filter2]\n\nCORRECT EXAMPLES:\n\nQ: \"what are top 5 hottest methods\"\nA: {\"query\": \"events/jdk.ExecutionSample/stackTrace/frames/0/method/type/name | groupBy(value) | top(5, by=count)\", \"explanation\": \"Uses ExecutionSample (only event type for CPU profiling), projects to method name from frame 0, groups by value\", \"confidence\": 0.95}\n\nQ: \"which threads allocated the most memory\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | groupBy(eventThread/javaName, agg=sum, value=bytes) | top(10, by=sum)\", \"explanation\": \"Allocation events use eventThread field (not thread or sampledThread), bytes field for memory (not weight)\", \"confidence\": 0.95}\n\nQ: \"top threads by execution samples\"\nA: {\"query\": \"events/jdk.ExecutionSample | groupBy(sampledThread/javaName) | top(10, by=count)\", \"explanation\": \"ExecutionSample uses sampledThread field (not eventThread), groups by thread name\", \"confidence\": 0.95}\n\nQ: \"GC events in young generation longer than 50ms\"\nA: {\"query\": \"events/jdk.GarbageCollection[name=~\\\".*Young.*\\\"][duration>50000000]\", \"explanation\": \"Chains two filters: regex match on name field, duration threshold. Both filters in [] brackets\", \"confidence\": 0.90}\n\nQ: \"top allocating classes\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | groupBy(objectClass/name, agg=sum, value=weight) | top(10, by=sum)\", \"explanation\": \"Groups allocations by class name and sums weight (not bytes) for allocation pressure\", \"confidence\": 0.95}\n\nQ: \"which monitors have the most contention\"\nA: {\"query\": \"events/jdk.JavaMonitorEnter | groupBy(monitorClass/name) | top(10, by=count)\", \"explanation\": \"Groups monitor enter events by monitor class\", \"confidence\": 0.95}\n\nQ: \"show network read events\"\nA: {\"query\": \"events/jdk.SocketRead\", \"explanation\": \"Selects all socket read events\", \"confidence\": 0.98}\n\nQ: \"file writes over 5MB\"\nA: {\"query\": \"events/jdk.FileWrite[bytesWritten>5242880]\", \"explanation\": \"FileWrite uses bytesWritten field\", \"confidence\": 0.95}\n\nQ: \"count exceptions by type\"\nA: {\"query\": \"events/jdk.JavaExceptionThrow | groupBy(thrownClass/name)\", \"explanation\": \"Groups exception throw events by exception class\", \"confidence\": 0.95}\n\nINCORRECT EXAMPLES - LEARN FROM THESE MISTAKES:\n\nQ: \"what are top 5 hottest methods\"\nWRONG: {\"query\": \"events/jdk.MethodSample | groupBy(methodName) | top(5, by=count)\", ...}\nWHY WRONG: (1) jdk.MethodSample event type DOES NOT EXIST - must use jdk.ExecutionSample (2) No projection to method name (3) Wrong field name\nCORRECT: {\"query\": \"events/jdk.ExecutionSample/stackTrace/frames/0/method/type/name | groupBy(value) | top(5, by=count)\", ...}\n\nQ: \"which threads allocated the most memory\"\nWRONG: {\"query\": \"events/jdk.ObjectAllocationSample | groupBy(thread/javaName, agg=sum, value=weight) | top(10, by=sum)\", ...}\nWHY WRONG: (1) Using thread/javaName instead of eventThread/javaName (2) Using weight instead of bytes for memory size\nCORRECT: {\"query\": \"events/jdk.ObjectAllocationSample | groupBy(eventThread/javaName, agg=sum, value=bytes) | top(10, by=sum)\", ...}\n\nQ: \"top threads by execution samples\"\nWRONG: {\"query\": \"events/jdk.ExecutionSample | groupBy(eventThread/javaName) | top(10, by=count)\", ...}\nWHY WRONG: ExecutionSample uses sampledThread/javaName NOT eventThread/javaName (different thread field!)\nCORRECT: {\"query\": \"events/jdk.ExecutionSample | groupBy(sampledThread/javaName) | top(10, by=count)\", ...}\n\nQ: \"GC events in young generation longer than 50ms\"\nWRONG: {\"query\": \"events/jdk.GarbageCollection[duration>50000000] | filter(name contains 'Young')\", ...}\nWHY WRONG: (1) No filter() operator exists (2) Wrong syntax for regex matching\nCORRECT: {\"query\": \"events/jdk.GarbageCollection[name=~\\\".*Young.*\\\"][duration>50000000]\", ...}\n\nQ: \"top allocating classes\"\nWRONG: {\"query\": \"events/jdk.ObjectAllocationSample | groupBy(eventThread/javaClass) | top(10, by=sum)\", ...}\nWHY WRONG: Using eventThread/javaClass instead of objectClass/name\nCORRECT: {\"query\": \"events/jdk.ObjectAllocationSample | groupBy(objectClass/name, agg=sum, value=weight) | top(10, by=sum)\", ...}\n\nQ: \"which monitors have the most contention\"\nWRONG: {\"query\": \"events/jdk.LockContended | groupBy(lockOwner/javaName) | top(10, by=count)\", ...}\nWHY WRONG: Using jdk.LockContended instead of jdk.JavaMonitorEnter\nCORRECT: {\"query\": \"events/jdk.JavaMonitorEnter | groupBy(monitorClass/name) | top(10, by=count)\", ...}\n\nKEY FIELD NAME PRECISION RULES:\n- ExecutionSample: Use 'sampledThread/javaName' for thread field\n- ObjectAllocationSample: Use 'eventThread/javaName' for thread field, 'bytes' for memory, 'weight' for allocation pressure\n- ThreadPark, JavaMonitorEnter, FileRead, FileWrite: Use 'eventThread/javaName' for thread field\n- CPU profiling: ONLY jdk.ExecutionSample exists (jdk.MethodSample does NOT exist)\n- Method extraction: Project to stackTrace/frames/0/method/type/name then groupBy(value)\n- Multiple filters: Chain with [filter1][filter2], regex uses [field=~\\\"pattern\\\"]\n- Never use: filter() operator, select() operator, thread/javaName (always eventThread or sampledThread)"
      }
    },
    {
      "id": "decorator-patterns",
      "description": "Add decorator examples for temporal correlation analysis (virtual threads, GC, safepoints, locks, I/O)",
      "modifications": {
        "customExamples": "CORE QUERY EXAMPLES:\n\nQ: \"top allocating classes\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | groupBy(objectClass/name, agg=sum, value=weight) | top(10, by=sum)\", \"explanation\": \"Groups allocations by class\", \"confidence\": 0.95}\n\nQ: \"which monitors have the most contention\"\nA: {\"query\": \"events/jdk.JavaMonitorEnter | groupBy(monitorClass/name) | top(10, by=count)\", \"explanation\": \"Groups monitor enter events by class\", \"confidence\": 0.95}\n\nQ: \"show file reads over 1MB\"\nA: {\"query\": \"events/jdk.FileRead[bytes>1048576]\", \"explanation\": \"Filters file reads\", \"confidence\": 0.98}\n\nQ: \"count GC events\"\nA: {\"query\": \"events/jdk.GarbageCollection | count()\", \"explanation\": \"Counts GC events\", \"confidence\": 0.98}\n\nDECORATOR QUERY EXAMPLES:\n\nQ: \"which methods are causing virtual thread pinning\"\nA: {\"query\": \"events/jdk.ExecutionSample | decorateByTime(jdk.VirtualThreadPinned, fields=duration) | groupBy(stackTrace/frames/0/method/type/name, agg=sum, value=$decorator.duration) | top(10, by=sum)\", \"explanation\": \"Correlates execution samples with pinning events using decorateByTime, groups by method and sums decorator duration field\", \"confidence\": 0.90}\n\nQ: \"which code allocates memory during garbage collection\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | decorateByTime(jdk.GCPhase, fields=name) | groupBy($decorator.name, agg=sum, value=allocationSize)\", \"explanation\": \"Decorates allocations with GC phase names using temporal overlap\", \"confidence\": 0.90}\n\nQ: \"what was the application doing during long safepoint pauses\"\nA: {\"query\": \"events/jdk.ExecutionSample | decorateByTime(jdk.SafepointBegin, fields=operation,duration) | groupBy($decorator.operation, agg=avg, value=$decorator.duration)\", \"explanation\": \"Correlates execution samples with safepoints\", \"confidence\": 0.90}\n\nQ: \"which monitors have cascading wait queues\"\nA: {\"query\": \"events/jdk.JavaMonitorWait | groupBy(monitorClass/name, agg=sum, value=duration) | top(10, by=sum)\", \"explanation\": \"Groups monitor waits by class and sums wait duration\", \"confidence\": 0.95}\n\nQ: \"which threads are blocked on I/O operations the most\"\nA: {\"query\": \"events/jdk.ThreadPark | decorateByTime(jdk.FileRead, fields=path) | groupBy(eventThread/javaName, agg=sum, value=duration) | top(10, by=sum)\", \"explanation\": \"Decorates thread park events with file read context\", \"confidence\": 0.90}\n\nQ: \"correlate monitor inflation events with contention\"\nA: {\"query\": \"events/jdk.JavaMonitorEnter | decorateByTime(jdk.JavaMonitorInflate, fields=monitorClass) | groupBy($decorator.monitorClass, agg=count)\", \"explanation\": \"Uses decorateByTime to join monitor events temporally\", \"confidence\": 0.90}\n\nQ: \"show pinned thread stack traces with duration over 100ms\"\nA: {\"query\": \"events/jdk.VirtualThreadPinned[duration>100000000]\", \"explanation\": \"Filters pinned thread events by duration\", \"confidence\": 0.95}\n\nQ: \"show allocation hot spots during young generation GC\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | decorateByTime(jdk.GarbageCollection, fields=gcId,name) | groupBy(objectClass/name, agg=sum, value=bytes) | top(10, by=sum)\", \"explanation\": \"Decorates allocations with GC events including name field\", \"confidence\": 0.90}\n\nQ: \"which threads allocate the most during GC phases\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | decorateByTime(jdk.GCPhase, fields=name) | groupBy(eventThread/javaName, agg=sum, value=bytes) | top(10, by=sum)\", \"explanation\": \"Decorates allocations with GC phases and groups by thread\", \"confidence\": 0.90}\n\nQ: \"find operations causing safepoint delays over 50ms\"\nA: {\"query\": \"events/jdk.SafepointBegin[duration>50000000] | groupBy(operation, agg=count)\", \"explanation\": \"Filters safepoints and groups by operation type\", \"confidence\": 0.95}\n\nQ: \"correlate JIT compilation with safepoint duration\"\nA: {\"query\": \"events/jdk.SafepointBegin | decorateByTime(jdk.Compilation, fields=method) | groupBy($decorator.method, agg=sum, value=duration)\", \"explanation\": \"Decorates safepoints with compilation method field\", \"confidence\": 0.90}\n\nQ: \"show thread starvation caused by lock contention\"\nA: {\"query\": \"events/jdk.JavaMonitorEnter[duration>100000000] | groupBy(eventThread/javaName, agg=count)\", \"explanation\": \"Filters long monitor enter events and groups by thread\", \"confidence\": 0.95}\n\nQ: \"correlate socket reads with thread parking duration\"\nA: {\"query\": \"events/jdk.SocketRead | decorateByTime(jdk.ThreadPark, fields=duration) | groupBy(address, agg=avg, value=$decorator.duration)\", \"explanation\": \"Decorates socket reads with thread park duration\", \"confidence\": 0.90}\n\nQ: \"detect blocking I/O causing thread starvation\"\nA: {\"query\": \"events/jdk.ThreadPark[duration>10000000] | decorateByTime(jdk.SocketRead, fields=bytesRead) | groupBy(eventThread/javaName, agg=count)\", \"explanation\": \"Filters long thread parks and decorates with socket read context\", \"confidence\": 0.90}\n\nCRITICAL DECORATOR SYNTAX RULES:\n\n1. Syntax: decorateByTime(EventType, fields=field1,field2) - fields parameter REQUIRED\n2. Decorator field access: MUST use $decorator.fieldName ($ prefix is REQUIRED)\n3. Decorator fields work in: groupBy keys, agg values, top sorting\n4. decorateByTime joins events that overlap in time on same thread\n5. DO NOT use filters inside decorateByTime - filter the primary events instead\n6. Examples: $decorator.duration, $decorator.name, $decorator.monitorClass\n\nCOMMON MISTAKES TO AVOID:\n\nWRONG: decorateByTime(jdk.Type) - missing fields parameter\nCORRECT: decorateByTime(jdk.Type, fields=field1)\n\nWRONG: groupBy(decorator.name) - missing $ prefix\nCORRECT: groupBy($decorator.name)\n\nWRONG: decorate(jdk.Type, fields=...) - wrong operator name\nCORRECT: decorateByTime(jdk.Type, fields=...)\n\nWRONG: decorateByTime(jdk.Type[filter], fields=...) - filters not supported inside decorateByTime\nCORRECT: events/jdk.PrimaryType[filter] | decorateByTime(jdk.Type, fields=...)\n\nKEY FIELD RULES:\n- ExecutionSample: Use 'sampledThread/javaName' for thread field\n- ObjectAllocationSample: Use 'eventThread/javaName', 'bytes' for memory, 'weight' for pressure\n- Virtual threads: jdk.VirtualThreadPinned event type for Java 21+\n- GC phases: jdk.GCPhase for phase-level analysis\n- Safepoints: jdk.SafepointBegin with 'operation' field\n- Network: jdk.SocketRead/SocketWrite with bytesRead/bytesWritten\n- File I/O: jdk.FileRead (bytes), jdk.FileWrite (bytesWritten)"
      }
    },
    {
      "id": "decorator-refined",
      "description": "Refined decorator patterns with precision rules for field names, event types, and when to use decorators",
      "modifications": {
        "customExamples": "WHEN TO USE DECORATORS:\n\nUse decorateByTime() ONLY when the question asks about temporal correlation between two event types:\n- \"during\" (e.g., \"allocations during GC\", \"what happened during safepoint\")\n- \"causing\" (e.g., \"methods causing pinning\", \"code causing delays\")\n- \"correlate\" (e.g., \"correlate X with Y\")\n- \"while\" (e.g., \"threads blocked while reading\")\n\nDO NOT use decorators for simple aggregations, filtering, or grouping of a single event type!\n\nCORRECT - NO DECORATOR NEEDED:\n\nQ: \"which threads allocated the most memory\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | groupBy(eventThread/javaName, agg=sum, value=bytes) | top(10, by=sum)\", \"explanation\": \"Simple aggregation of single event type - no temporal correlation needed\", \"confidence\": 0.95}\n\nQ: \"top threads by virtual thread pinning duration\"\nA: {\"query\": \"events/jdk.VirtualThreadPinned | groupBy(eventThread/javaName, agg=sum, value=duration) | top(10, by=sum)\", \"explanation\": \"Direct aggregation of pinning events - no decorator needed\", \"confidence\": 0.95}\n\nQ: \"top threads by execution samples\"\nA: {\"query\": \"events/jdk.ExecutionSample | groupBy(sampledThread/javaName) | top(10, by=count)\", \"explanation\": \"Simple grouping of execution samples - no decorator needed\", \"confidence\": 0.95}\n\nQ: \"threads with longest park times\"\nA: {\"query\": \"events/jdk.ThreadPark | groupBy(eventThread/javaName, agg=sum, value=duration) | top(10, by=sum)\", \"explanation\": \"Direct aggregation requires explicit agg=sum, value=duration\", \"confidence\": 0.95}\n\nCORRECT - DECORATOR REQUIRED:\n\nQ: \"which methods are causing virtual thread pinning\"\nA: {\"query\": \"events/jdk.ExecutionSample | decorateByTime(jdk.VirtualThreadPinned, fields=duration) | groupBy(stackTrace/frames/0/method/type/name, agg=sum, value=$decorator.duration) | top(10, by=sum)\", \"explanation\": \"Asks what CODE (methods) causes pinning - needs temporal correlation between samples and pinning\", \"confidence\": 0.90}\n\nQ: \"which code allocates memory during garbage collection\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | decorateByTime(jdk.GCPhase, fields=name) | groupBy($decorator.name, agg=sum, value=allocationSize)\", \"explanation\": \"Asks about allocations DURING GC phases - needs temporal correlation\", \"confidence\": 0.90}\n\nQ: \"what was the application doing during long safepoint pauses\"\nA: {\"query\": \"events/jdk.ExecutionSample | decorateByTime(jdk.SafepointBegin, fields=operation,duration) | groupBy($decorator.operation, agg=avg, value=$decorator.duration)\", \"explanation\": \"Asks what app was doing DURING safepoints - needs temporal correlation\", \"confidence\": 0.90}\n\nQ: \"which threads are blocked on I/O operations the most\"\nA: {\"query\": \"events/jdk.ThreadPark | decorateByTime(jdk.FileRead, fields=path) | groupBy(eventThread/javaName, agg=sum, value=duration) | top(10, by=sum)\", \"explanation\": \"Correlates parking with I/O context to find threads blocked ON I/O\", \"confidence\": 0.90}\n\nTHREAD FIELD PRECISION:\n\nExecutionSample: sampledThread/javaName (the thread being sampled)\nObjectAllocationSample: eventThread/javaName (the thread doing allocation)\nThreadPark: eventThread/javaName\nJavaMonitorEnter: eventThread/javaName\nFileRead/FileWrite: eventThread/javaName\nSocketRead/SocketWrite: eventThread/javaName\nVirtualThreadPinned: eventThread/javaName\nSafepointBegin: eventThread/javaName\n\nCOMMON FIELD NAME ERRORS - MEMORIZE THESE:\n\nFileRead: bytes (NOT bytesRead)\nFileWrite: bytesWritten (NOT bytes)\nSocketRead: bytesRead (NOT bytes)\nSocketWrite: bytesWritten (NOT bytes)\nObjectAllocationSample: bytes (for memory), weight (for allocation pressure), allocationSize (alias for bytes)\nClassLoad: loadedClass/name (NOT className)\nJavaExceptionThrow: thrownClass/name (NOT exceptionType)\nJavaMonitorEnter: monitorClass/name (NOT lockClass)\nJavaMonitorWait: monitorClass/name (NOT waitClass)\nExecutionSample: sampledThread/javaName (NOT eventThread)\n\nEVENT TYPE DISTINCTIONS:\n\nGC Analysis:\n- jdk.GarbageCollection: Full GC events with name, gcId, cause, duration\n- jdk.GCPhase: Granular GC phase events (pause phases, concurrent phases)\n- For \"during GC\": Use jdk.GCPhase for phase-level detail\n- For \"GC events\": Use jdk.GarbageCollection for full collection events\n\nException Tracking:\n- jdk.JavaExceptionThrow: Actual exception throw events (CORRECT)\n- jdk.ExceptionStatistics: Does NOT exist (WRONG)\n\nThread Operations:\n- jdk.ThreadPark: Thread parking events (CORRECT)\n- jdk.ThreadWait: Does NOT exist (use JavaMonitorWait instead)\n- jdk.ThreadPinning: Does NOT exist (use VirtualThreadPinned)\n\nMonitor Operations:\n- jdk.JavaMonitorEnter: Monitor entry/contention (CORRECT)\n- jdk.JavaMonitorWait: Monitor wait events (CORRECT)\n- jdk.JavaMonitorInflate: Monitor inflation events (CORRECT)\n- jdk.LockContended: Does NOT exist (WRONG)\n\nCPU Profiling:\n- jdk.ExecutionSample: CPU profiling samples (CORRECT, ONLY option)\n- jdk.MethodSample: Does NOT exist (WRONG)\n- jdk.VMOperationSample: Does NOT exist (WRONG)\n\nVirtual Threads (Java 21+):\n- jdk.VirtualThreadPinned: Virtual thread pinning events (CORRECT)\n- jdk.VMThreadPinning: Does NOT exist (WRONG)\n- jdk.ThreadPinning: Does NOT exist (WRONG)\n\nAGGREGATION SYNTAX RULES:\n\nWhen using top() with duration or sum, you MUST specify the aggregation explicitly:\n\nWRONG: events/jdk.ThreadPark | groupBy(eventThread/javaName) | top(10, by=duration)\nCORRECT: events/jdk.ThreadPark | groupBy(eventThread/javaName, agg=sum, value=duration) | top(10, by=sum)\n\nWRONG: events/jdk.SocketRead | groupBy(address)\nCORRECT (if summing): events/jdk.SocketRead | groupBy(address, agg=sum, value=bytesRead)\nCORRECT (if counting): events/jdk.SocketRead | groupBy(address)\n\nFor \"longest\", \"most time\", \"highest duration\": Use agg=sum, value=duration with top(N, by=sum)\nFor \"most events\", \"most contention\", \"top N\": Use simple groupBy with top(N, by=count)\n\nPRIMARY VS DECORATOR EVENT SELECTION:\n\nPrimary event = the thing you're analyzing\nDecorator event = the context/condition\n\nQ: \"which methods are causing pinning\"\n- Analyzing: methods (from ExecutionSample)\n- Context: pinning (VirtualThreadPinned)\n- PRIMARY: ExecutionSample | decorateByTime(VirtualThreadPinned, ...)\n\nQ: \"what was app doing during safepoints\"\n- Analyzing: app activity (ExecutionSample)\n- Context: safepoints (SafepointBegin)\n- PRIMARY: ExecutionSample | decorateByTime(SafepointBegin, ...)\n\nQ: \"which code allocates during GC\"\n- Analyzing: allocations (ObjectAllocationSample)\n- Context: GC phases (GCPhase)\n- PRIMARY: ObjectAllocationSample | decorateByTime(GCPhase, ...)\n\nQ: \"threads blocked on I/O\"\n- Analyzing: thread parking (ThreadPark)\n- Context: I/O operations (FileRead/SocketRead)\n- PRIMARY: ThreadPark | decorateByTime(FileRead, ...)\n\nNEVER SWAP: If the question asks about X during/while/causing Y:\n- PRIMARY is X (the thing being analyzed)\n- DECORATOR is Y (the condition/context)\n\nEXAMPLE CORRECTIONS:\n\nQ: \"which monitors cause the most pinning events\"\nWRONG: {\"query\": \"events/jdk.JavaMonitorEnter | groupBy(monitorClass/name) | top(10, by=count)\", ...}\nWHY WRONG: Not using decorator for temporal correlation - doesn't show causation\nCORRECT: {\"query\": \"events/jdk.VirtualThreadPinned | decorateByTime(jdk.JavaMonitorEnter, fields=monitorClass) | groupBy($decorator.monitorClass, agg=count)\", ...}\n\nQ: \"correlate thread pinning with execution samples\"\nWRONG: {\"query\": \"events/jdk.ExecutionSample | decorateByTime(jdk.VirtualThreadPinned, fields=duration) | groupBy(stackTrace/frames/0/method/type/name, agg=sum, value=$decorator.duration) | top(10, by=sum)\", ...}\nWHY WRONG: Query asks to correlate, should count correlation not sum duration\nCORRECT: {\"query\": \"events/jdk.ExecutionSample | decorateByTime(jdk.VirtualThreadPinned, fields=duration,stackTrace) | groupBy($decorator.stackTrace/frames/0/method/type/name, agg=count)\", ...}\n\nQ: \"which code allocates memory during garbage collection\"\nWRONG: {\"query\": \"events/jdk.ObjectAllocationSample | decorateByTime(jdk.GarbageCollection, fields=name) | groupBy($decorator.name, agg=sum, value=allocationSize)\", ...}\nWHY WRONG: Should use jdk.GCPhase for phase-level detail, not jdk.GarbageCollection\nCORRECT: {\"query\": \"events/jdk.ObjectAllocationSample | decorateByTime(jdk.GCPhase, fields=name) | groupBy($decorator.name, agg=sum, value=allocationSize)\", ...}\n\nQ: \"top threads by virtual thread pinning duration\"\nWRONG: {\"query\": \"events/jdk.ExecutionSample | decorateByTime(jdk.VirtualThreadPinned, fields=duration) | groupBy(stackTrace/frames/0/method/type/name, agg=sum, value=$decorator.duration) | top(10, by=sum)\", ...}\nWHY WRONG: Question asks for threads, not methods - no decorator needed for simple aggregation\nCORRECT: {\"query\": \"events/jdk.VirtualThreadPinned | groupBy(eventThread/javaName, agg=sum, value=duration) | top(10, by=sum)\", ...}\n\nQ: \"find allocation storms triggering emergency GC\"\nWRONG: {\"query\": \"events/jdk.ObjectAllocationSample | decorateByTime(jdk.GarbageCollection, fields=gcId) | groupBy(objectClass/name, agg=sum, value=$decorator.duration) | top(10, by=sum)\", ...}\nWHY WRONG: Should group by gcId to find allocation counts per GC, not by class name; GarbageCollection doesn't have duration in decorator\nCORRECT: {\"query\": \"events/jdk.ObjectAllocationSample | decorateByTime(jdk.GarbageCollection, fields=gcId,name,cause) | groupBy($decorator.gcId, agg=count)\", ...}\n\nQ: \"what was the application doing during long safepoint pauses\"\nWRONG: {\"query\": \"events/jdk.SafepointBegin | decorateByTime(jdk.ExecutionSample, fields=operation,duration) | groupBy($decorator.operation, agg=avg, value=$decorator.duration)\", ...}\nWHY WRONG: Swapped primary and decorator - should analyze ExecutionSample (app activity) with SafepointBegin as context\nCORRECT: {\"query\": \"events/jdk.ExecutionSample | decorateByTime(jdk.SafepointBegin, fields=operation,duration) | groupBy($decorator.operation, agg=avg, value=$decorator.duration)\", ...}\n\nQ: \"statistics on object allocation sizes\"\nWRONG: {\"query\": \"events/jdk.ObjectAllocationSample | stats(allocationSize)\", ...}\nWHY WRONG: Field is called 'weight' not 'allocationSize'\nCORRECT: {\"query\": \"events/jdk.ObjectAllocationSample | stats(weight)\", ...}\n\nQ: \"network traffic by remote address\"\nWRONG: {\"query\": \"events/jdk.SocketRead | groupBy(address)\", ...}\nWHY WRONG: Missing aggregation - should sum bytesRead\nCORRECT: {\"query\": \"events/jdk.SocketRead | groupBy(address, agg=sum, value=bytesRead)\", ...}\n\nQ: \"GC events in young generation longer than 50ms\"\nWRONG: {\"query\": \"events/jdk.GarbageCollection[gcId>50]\", ...}\nWHY WRONG: Completely wrong filter - should use regex for name and duration threshold\nCORRECT: {\"query\": \"events/jdk.GarbageCollection[name=~\\\".*Young.*\\\"][duration>50000000]\", ...}\n\nQ: \"file writes over 5MB\"\nWRONG: {\"query\": \"events/jdk.FileWrite[bytes>5242880]\", ...}\nWHY WRONG: FileWrite uses 'bytesWritten' field, not 'bytes'\nCORRECT: {\"query\": \"events/jdk.FileWrite[bytesWritten>5242880]\", ...}\n\nQ: \"count exceptions by type\"\nWRONG: {\"query\": \"events/jdk.ExceptionStatistics | groupBy(type) | count()\", ...}\nWHY WRONG: jdk.ExceptionStatistics doesn't exist, should use jdk.JavaExceptionThrow\nCORRECT: {\"query\": \"events/jdk.JavaExceptionThrow | groupBy(thrownClass/name)\", ...}\n\nQ: \"network reads larger than 1KB\"\nWRONG: {\"query\": \"events/jdk.SocketRead[bytes>1048576]\", ...}\nWHY WRONG: (1) Wrong threshold (1048576 = 1MB not 1KB) (2) SocketRead uses 'bytesRead' not 'bytes'\nCORRECT: {\"query\": \"events/jdk.SocketRead[bytesRead>1024]\", ...}\n\nQ: \"which classes took longest to load\"\nWRONG: {\"query\": \"events/jdk.ClassLoad | groupBy(classname) | top(10, by=duration)\", ...}\nWHY WRONG: (1) Field is loadedClass/name not classname (2) Missing agg=max\nCORRECT: {\"query\": \"events/jdk.ClassLoad | groupBy(loadedClass/name, agg=max, value=duration) | top(10, by=max)\", ...}\n\nSUMMARY CHECKLIST:\n\n1. Does question ask about correlation/causation? → Use decorator\n2. Simple aggregation of single event type? → NO decorator\n3. Thread field: ExecutionSample uses sampledThread, everything else uses eventThread\n4. FileRead uses 'bytes', FileWrite uses 'bytesWritten'\n5. SocketRead/SocketWrite use 'bytesRead'/'bytesWritten'\n6. ObjectAllocationSample: 'bytes' for memory, 'weight' for pressure\n7. Exception tracking: jdk.JavaExceptionThrow with thrownClass/name\n8. Monitor operations: jdk.JavaMonitorEnter/Wait/Inflate\n9. GC phases: jdk.GCPhase for \"during GC\", jdk.GarbageCollection for GC events\n10. Always use agg=sum/max/avg with explicit value when using top() with duration/sum\n11. Primary event = thing being analyzed, Decorator = context/condition\n12. Never swap primary and decorator"
      }
    },
    {
      "id": "decorator-targeted",
      "description": "Concise fixes for 15 remaining failures: when NOT to use decorators, field names, aggregations, decorator usage",
      "modifications": {
        "customExamples": "DECORATOR EXAMPLES:\n\nQ: \"which methods are causing virtual thread pinning\"\nA: {\"query\": \"events/jdk.ExecutionSample | decorateByTime(jdk.VirtualThreadPinned, fields=duration) | groupBy(stackTrace/frames/0/method/type/name, agg=sum, value=$decorator.duration) | top(10, by=sum)\", \"explanation\": \"Correlates methods with pinning\", \"confidence\": 0.90}\n\nQ: \"which code allocates memory during garbage collection\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | decorateByTime(jdk.GCPhase, fields=name) | groupBy($decorator.name, agg=sum, value=allocationSize)\", \"explanation\": \"Allocations DURING GC phases\", \"confidence\": 0.90}\n\nQ: \"which monitors cause the most pinning events\"\nA: {\"query\": \"events/jdk.VirtualThreadPinned | decorateByTime(jdk.JavaMonitorEnter, fields=monitorClass) | groupBy($decorator.monitorClass, agg=count)\", \"explanation\": \"Monitors CAUSING pinning - needs decorator\", \"confidence\": 0.90}\n\nQ: \"correlate thread pinning with execution samples\"\nA: {\"query\": \"events/jdk.ExecutionSample | decorateByTime(jdk.VirtualThreadPinned, fields=duration,stackTrace) | groupBy($decorator.stackTrace/frames/0/method/type/name, agg=count)\", \"explanation\": \"Correlate means count occurrences, not sum duration\", \"confidence\": 0.90}\n\nQ: \"find allocation storms triggering emergency GC\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | decorateByTime(jdk.GarbageCollection, fields=gcId,name,cause) | groupBy($decorator.gcId, agg=count)\", \"explanation\": \"Group by gcId to count allocations per GC\", \"confidence\": 0.90}\n\nQ: \"what was the application doing during long safepoint pauses\"\nA: {\"query\": \"events/jdk.ExecutionSample | decorateByTime(jdk.SafepointBegin, fields=operation,duration) | groupBy($decorator.operation, agg=avg, value=$decorator.duration)\", \"explanation\": \"Primary=ExecutionSample (activity), Decorator=SafepointBegin (context)\", \"confidence\": 0.90}\n\nNO DECORATOR NEEDED:\n\nQ: \"what are top 5 hottest methods\"\nA: {\"query\": \"events/jdk.ExecutionSample/stackTrace/frames/0/method/type/name | groupBy(value) | top(5, by=count)\", \"explanation\": \"Simple hotspot query - NO decorator\", \"confidence\": 0.95}\n\nQ: \"which threads allocated the most memory\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | groupBy(eventThread/javaName, agg=sum, value=bytes) | top(10, by=sum)\", \"explanation\": \"Simple aggregation - NO decorator\", \"confidence\": 0.95}\n\nQ: \"top threads by virtual thread pinning duration\"\nA: {\"query\": \"events/jdk.VirtualThreadPinned | groupBy(eventThread/javaName, agg=sum, value=duration) | top(10, by=sum)\", \"explanation\": \"Direct aggregation of pinning events - NO decorator\", \"confidence\": 0.95}\n\nQ: \"threads with longest park times\"\nA: {\"query\": \"events/jdk.ThreadPark | groupBy(eventThread/javaName, agg=sum, value=duration) | top(10, by=sum)\", \"explanation\": \"MUST use agg=sum, value=duration before top()\", \"confidence\": 0.95}\n\nFIELD NAME PRECISION:\n\nQ: \"network reads larger than 1KB\"\nA: {\"query\": \"events/jdk.SocketRead[bytesRead>1024]\", \"explanation\": \"SocketRead uses bytesRead field, 1KB=1024 bytes\", \"confidence\": 0.95}\n\nQ: \"file writes over 5MB\"\nA: {\"query\": \"events/jdk.FileWrite[bytesWritten>5242880]\", \"explanation\": \"FileWrite uses bytesWritten (NOT bytes)\", \"confidence\": 0.95}\n\nQ: \"which classes took longest to load\"\nA: {\"query\": \"events/jdk.ClassLoad | groupBy(loadedClass/name, agg=max, value=duration) | top(10, by=max)\", \"explanation\": \"Field is loadedClass/name (NOT classname), use agg=max for longest\", \"confidence\": 0.95}\n\nQ: \"statistics on object allocation sizes\"\nA: {\"query\": \"events/jdk.ObjectAllocationSample | stats(weight)\", \"explanation\": \"Field is weight (NOT allocationSize)\", \"confidence\": 0.95}\n\nQ: \"count exceptions by type\"\nA: {\"query\": \"events/jdk.JavaExceptionThrow | groupBy(thrownClass/name)\", \"explanation\": \"Event is JavaExceptionThrow (NOT ExceptionStatistics)\", \"confidence\": 0.95}\n\nAGGREGATION RULES:\n\nQ: \"network traffic by remote address\"\nA: {\"query\": \"events/jdk.SocketRead | groupBy(address, agg=sum, value=bytesRead)\", \"explanation\": \"Traffic = sum bytes, MUST specify agg=sum, value=bytesRead\", \"confidence\": 0.95}\n\nQ: \"GC events in young generation longer than 50ms\"\nA: {\"query\": \"events/jdk.GarbageCollection[name=~\\\".*Young.*\\\"][duration>50000000]\", \"explanation\": \"Use regex [name=~\\\".*Young.*\\\"] and duration filter [duration>50000000]\", \"confidence\": 0.90}\n\nCRITICAL RULES:\n\n1. NO DECORATOR for simple queries:\n   - \"top X\", \"which threads\", \"hottest methods\" = NO decorator\n   - ONLY use decorator for: \"during\", \"causing\", \"correlate\", \"while\"\n\n2. FIELD NAMES:\n   - FileRead: bytes\n   - FileWrite: bytesWritten\n   - SocketRead/SocketWrite: bytesRead/bytesWritten\n   - ObjectAllocationSample: bytes (memory), weight (allocation pressure)\n   - ClassLoad: loadedClass/name\n   - JavaExceptionThrow: thrownClass/name\n   - ExecutionSample: sampledThread/javaName\n   - Everything else: eventThread/javaName\n\n3. AGGREGATION:\n   - For \"longest/most time\": agg=sum, value=duration THEN top(N, by=sum)\n   - For \"traffic/total bytes\": agg=sum, value=bytes THEN top(N, by=sum)\n   - NEVER: top(N, by=duration) - must use agg=sum first\n\n4. DECORATOR SEMANTICS:\n   - \"correlate X with Y\" = count occurrences (agg=count), NOT sum duration\n   - \"X causing Y\" = primary is Y, decorator is X\n   - \"during X\" = primary is the activity, decorator is the context (X)\n   - \"storms triggering GC\" = group by $decorator.gcId to count per GC\n\n5. EVENT TYPES:\n   - Exceptions: jdk.JavaExceptionThrow (NOT ExceptionStatistics)\n   - Virtual threads: jdk.VirtualThreadPinned (NOT VMThreadPinning)\n   - Thread parking: jdk.ThreadPark (NOT ThreadWait)\n   - Monitors: jdk.JavaMonitorEnter/Wait/Inflate (NOT LockContended)\n\nINCORRECT EXAMPLES:\n\nQ: \"what are top 5 hottest methods\"\nWRONG: events/jdk.ExecutionSample | decorateByTime(jdk.MethodInvoke, fields=name) | ...\nCORRECT: events/jdk.ExecutionSample/stackTrace/frames/0/method/type/name | groupBy(value) | top(5, by=count)\n\nQ: \"which threads allocated the most memory\"\nWRONG: events/jdk.ObjectAllocationSample | decorateByTime(jdk.GCPhase, fields=name) | groupBy(eventThread/javaName, agg=sum, value=bytes) | top(10, by=sum)\nCORRECT: events/jdk.ObjectAllocationSample | groupBy(eventThread/javaName, agg=sum, value=bytes) | top(10, by=sum)\n\nQ: \"network reads larger than 1KB\"\nWRONG: events/jdk.SocketRead[bytes>1048576]\nCORRECT: events/jdk.SocketRead[bytesRead>1024]\n\nQ: \"threads with longest park times\"\nWRONG: events/jdk.ThreadPark | groupBy(eventThread/javaName) | top(10, by=duration)\nCORRECT: events/jdk.ThreadPark | groupBy(eventThread/javaName, agg=sum, value=duration) | top(10, by=sum)\n\nQ: \"count exceptions by type\"\nWRONG: events/jdk.ExceptionStatistics | groupBy(type/name) | count()\nCORRECT: events/jdk.JavaExceptionThrow | groupBy(thrownClass/name)\n\nQ: \"top threads by virtual thread pinning duration\"\nWRONG: events/jdk.ExecutionSample | decorateByTime(jdk.VirtualThreadPinned, fields=duration) | groupBy(stackTrace/frames/0/method/type/name, agg=sum, value=$decorator.duration) | top(10, by=sum)\nCORRECT: events/jdk.VirtualThreadPinned | groupBy(eventThread/javaName, agg=sum, value=duration) | top(10, by=sum)\n\nQ: \"which monitors cause the most pinning events\"\nWRONG: events/jdk.JavaMonitorEnter | groupBy(monitorClass/name) | top(10, by=count)\nCORRECT: events/jdk.VirtualThreadPinned | decorateByTime(jdk.JavaMonitorEnter, fields=monitorClass) | groupBy($decorator.monitorClass, agg=count)\n\nQ: \"correlate thread pinning with execution samples\"\nWRONG: events/jdk.ExecutionSample | decorateByTime(jdk.VirtualThreadPinned, fields=duration) | groupBy(stackTrace/frames/0/method/type/name, agg=sum, value=$decorator.duration) | top(10, by=sum)\nCORRECT: events/jdk.ExecutionSample | decorateByTime(jdk.VirtualThreadPinned, fields=duration,stackTrace) | groupBy($decorator.stackTrace/frames/0/method/type/name, agg=count)\n\nQ: \"what was the application doing during long safepoint pauses\"\nWRONG: events/jdk.SafepointBegin | decorateByTime(jdk.ExecutionSample, fields=operation,duration) | groupBy($decorator.operation, agg=avg, value=$decorator.duration)\nCORRECT: events/jdk.ExecutionSample | decorateByTime(jdk.SafepointBegin, fields=operation,duration) | groupBy($decorator.operation, agg=avg, value=$decorator.duration)"
      }
    }
  ]
}
