package io.jafar.parser.benchmark;

import io.jafar.parser.api.ParsingContext;
import io.jafar.parser.api.TypedJafarParser;
import io.jafar.parser.benchmark.events.*;
import io.jafar.parser.internal_api.GlobalHandlerCache;
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryPoolMXBean;
import java.lang.management.MemoryUsage;
import java.net.URL;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.infra.Blackhole;

/**
 * JMH benchmark comparing runtime bytecode generation vs build-time generated handlers.
 *
 * <p>This benchmark measures the performance difference between:
 *
 * <ul>
 *   <li><b>Runtime generation</b>: Handlers generated via ASM at first use (current approach)
 *   <li><b>Build-time generation</b>: Handlers generated by annotation processor during compilation
 * </ul>
 *
 * <p>Key metrics:
 *
 * <ul>
 *   <li>Throughput (ops/s) - how many recordings can be parsed per second
 *   <li>Allocation rate (MB/s) - memory allocation pressure
 *   <li>Metaspace usage - class loading overhead
 *   <li>Warmup time - time to reach stable performance
 * </ul>
 *
 * <p>Expected benefits of build-time generation:
 *
 * <ul>
 *   <li>No runtime bytecode generation overhead
 *   <li>Faster startup (handlers already loaded)
 *   <li>Better JIT optimization (static code, no reflection)
 *   <li>Reduced metaspace pressure
 *   <li>GraalVM native-image compatible
 * </ul>
 *
 * <p>To run: {@code ./gradlew jmh -Pjmh.include=BuildTimeHandlerBenchmark}
 */
@State(Scope.Benchmark)
@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 10, time = 2, timeUnit = TimeUnit.SECONDS)
@Fork(
    value = 1,
    jvmArgs = {"-Xms2g", "-Xmx2g"})
public class BuildTimeHandlerBenchmark {

  private Path testFile;
  private MemoryPoolMXBean metaspacePool;

  @Setup(Level.Trial)
  public void setup() throws Exception {
    // Use test file with ExecutionSample events
    URL resource = getClass().getClassLoader().getResource("test-ap.jfr");
    if (resource == null) {
      throw new IllegalStateException("test-ap.jfr not found in test resources");
    }
    testFile = Paths.get(resource.toURI());

    // Warm up file system caching
    try (TypedJafarParser parser = TypedJafarParser.open(testFile)) {
      parser.run();
    }

    // Find metaspace memory pool for tracking
    for (MemoryPoolMXBean pool : ManagementFactory.getMemoryPoolMXBeans()) {
      if (pool.getName().contains("Metaspace")) {
        metaspacePool = pool;
        break;
      }
    }

    // Clear global cache before benchmark
    GlobalHandlerCache.getInstance().clear();
  }

  @TearDown(Level.Iteration)
  public void printStats() {
    System.out.printf(
        "Cache: size=%d, hits=%d, misses=%d, hit_rate=%.1f%%%n",
        GlobalHandlerCache.getInstance().size(),
        GlobalHandlerCache.getInstance().getTotalHits(),
        GlobalHandlerCache.getInstance().getTotalMisses(),
        GlobalHandlerCache.getInstance().getHitRate());

    if (metaspacePool != null) {
      MemoryUsage usage = metaspacePool.getUsage();
      System.out.printf(
          "Metaspace: used=%d MB, committed=%d MB%n",
          usage.getUsed() / (1024 * 1024), usage.getCommitted() / (1024 * 1024));
    }
  }

  /**
   * Baseline: Parse with runtime bytecode generation (current approach).
   *
   * <p>Handlers are generated via ASM at first use, then cached in GlobalHandlerCache. This
   * involves:
   *
   * <ul>
   *   <li>Reflection to inspect interface methods
   *   <li>ASM bytecode generation
   *   <li>Class loading and linking
   *   <li>JIT compilation of generated code
   * </ul>
   */
  @Benchmark
  public void parseWithRuntimeGeneration(Blackhole bh) throws Exception {
    ParsingContext ctx = ParsingContext.create();
    AtomicInteger eventCount = new AtomicInteger();
    AtomicLong threadIdSum = new AtomicLong();
    AtomicInteger stackDepthSum = new AtomicInteger();

    try (TypedJafarParser parser = ctx.newTypedParser(testFile)) {
      parser.handle(
          JFRExecutionSample.class,
          (event, ctl) -> {
            JFRThread thread = event.sampledThread();
            JFRStackTrace stackTrace = event.stackTrace();

            if (thread != null) {
              bh.consume(thread.javaThreadId());
              threadIdSum.addAndGet(thread.javaThreadId());
              bh.consume(thread.javaName());
            }

            if (stackTrace != null && stackTrace.frames() != null) {
              stackDepthSum.addAndGet(stackTrace.frames().length);
              for (JFRStackFrame frame : stackTrace.frames()) {
                JFRMethod method = frame.method();
                if (method != null) {
                  bh.consume(method.name());
                  JFRClass clazz = method.type();
                  if (clazz != null) {
                    bh.consume(clazz.name());
                  }
                }
              }
            }

            eventCount.incrementAndGet();
          });
      parser.run();
    }

    bh.consume(eventCount.get());
    bh.consume(threadIdSum.get());
    bh.consume(stackDepthSum.get());
  }

  /**
   * Build-time: Parse with annotation processor generated handlers.
   *
   * <p>Handlers are generated by jafar-processor during compilation and registered via factories.
   * Benefits:
   *
   * <ul>
   *   <li>No runtime bytecode generation
   *   <li>Handlers already loaded and JIT-compiled
   *   <li>Thread-local caching reduces allocations
   *   <li>Static type IDs injected at binding time
   * </ul>
   */
  @Benchmark
  public void parseWithBuildTimeGeneration(Blackhole bh) throws Exception {
    ParsingContext ctx = ParsingContext.create();
    AtomicInteger eventCount = new AtomicInteger();
    AtomicLong threadIdSum = new AtomicLong();
    AtomicInteger stackDepthSum = new AtomicInteger();

    try (TypedJafarParser parser = ctx.newTypedParser(testFile)) {
      // Register build-time generated factories
      parser.registerFactory(new JFRExecutionSampleFactory());
      parser.registerFactory(new JFRThreadFactory());
      parser.registerFactory(new JFRThreadGroupFactory());
      parser.registerFactory(new JFRStackTraceFactory());
      parser.registerFactory(new JFRStackFrameFactory());
      parser.registerFactory(new JFRMethodFactory());
      parser.registerFactory(new JFRClassFactory());
      parser.registerFactory(new JFRClassLoaderFactory());
      parser.registerFactory(new JFRPackageFactory());
      parser.registerFactory(new JFRModuleFactory());
      parser.registerFactory(new JFRThreadStateFactory());

      parser.handle(
          JFRExecutionSample.class,
          (event, ctl) -> {
            JFRThread thread = event.sampledThread();
            JFRStackTrace stackTrace = event.stackTrace();

            if (thread != null) {
              bh.consume(thread.javaThreadId());
              threadIdSum.addAndGet(thread.javaThreadId());
              bh.consume(thread.javaName());
            }

            if (stackTrace != null && stackTrace.frames() != null) {
              stackDepthSum.addAndGet(stackTrace.frames().length);
              for (JFRStackFrame frame : stackTrace.frames()) {
                JFRMethod method = frame.method();
                if (method != null) {
                  bh.consume(method.name());
                  JFRClass clazz = method.type();
                  if (clazz != null) {
                    bh.consume(clazz.name());
                  }
                }
              }
            }

            eventCount.incrementAndGet();
          });
      parser.run();
    }

    bh.consume(eventCount.get());
    bh.consume(threadIdSum.get());
    bh.consume(stackDepthSum.get());
  }

  /**
   * Allocation profile for runtime generation.
   *
   * <p>Run with: {@code ./gradlew jmh
   * -Pjmh.include=BuildTimeHandlerBenchmark.allocationRuntimeGeneration -Pjmh.prof=gc}
   */
  @Benchmark
  public void allocationRuntimeGeneration(Blackhole bh) throws Exception {
    ParsingContext ctx = ParsingContext.create();
    AtomicInteger eventCount = new AtomicInteger();

    try (TypedJafarParser parser = ctx.newTypedParser(testFile)) {
      parser.handle(
          JFRExecutionSample.class,
          (event, ctl) -> {
            bh.consume(event);
            eventCount.incrementAndGet();
          });
      parser.run();
    }

    bh.consume(eventCount.get());
  }

  /**
   * Allocation profile for build-time generation.
   *
   * <p>Run with: {@code ./gradlew jmh
   * -Pjmh.include=BuildTimeHandlerBenchmark.allocationBuildTimeGeneration -Pjmh.prof=gc}
   *
   * <p>Expected: Lower allocation rate due to thread-local caching and no reflection/bytecode
   * generation.
   */
  @Benchmark
  public void allocationBuildTimeGeneration(Blackhole bh) throws Exception {
    ParsingContext ctx = ParsingContext.create();
    AtomicInteger eventCount = new AtomicInteger();

    try (TypedJafarParser parser = ctx.newTypedParser(testFile)) {
      parser.registerFactory(new JFRExecutionSampleFactory());
      parser.registerFactory(new JFRThreadFactory());
      parser.registerFactory(new JFRThreadGroupFactory());
      parser.registerFactory(new JFRStackTraceFactory());
      parser.registerFactory(new JFRStackFrameFactory());
      parser.registerFactory(new JFRMethodFactory());
      parser.registerFactory(new JFRClassFactory());
      parser.registerFactory(new JFRClassLoaderFactory());
      parser.registerFactory(new JFRPackageFactory());
      parser.registerFactory(new JFRModuleFactory());
      parser.registerFactory(new JFRThreadStateFactory());

      parser.handle(
          JFRExecutionSample.class,
          (event, ctl) -> {
            bh.consume(event);
            eventCount.incrementAndGet();
          });
      parser.run();
    }

    bh.consume(eventCount.get());
  }

  /**
   * Coldstart performance: Parse immediately after JVM startup.
   *
   * <p>Measures how fast each approach reaches steady-state performance. Build-time generation
   * should have faster startup since handlers are pre-compiled.
   */
  @Benchmark
  @Fork(1)
  @Warmup(iterations = 0)
  @Measurement(iterations = 5)
  public void coldStartRuntimeGeneration(Blackhole bh) throws Exception {
    ParsingContext ctx = ParsingContext.create();
    AtomicInteger eventCount = new AtomicInteger();

    try (TypedJafarParser parser = ctx.newTypedParser(testFile)) {
      parser.handle(
          JFRExecutionSample.class,
          (event, ctl) -> {
            bh.consume(event.startTime());
            eventCount.incrementAndGet();
          });
      parser.run();
    }

    bh.consume(eventCount.get());
  }

  /**
   * Coldstart performance for build-time generation.
   *
   * <p>Expected: Faster than runtime generation since no bytecode generation or class loading
   * overhead.
   */
  @Benchmark
  @Fork(1)
  @Warmup(iterations = 0)
  @Measurement(iterations = 5)
  public void coldStartBuildTimeGeneration(Blackhole bh) throws Exception {
    ParsingContext ctx = ParsingContext.create();
    AtomicInteger eventCount = new AtomicInteger();

    try (TypedJafarParser parser = ctx.newTypedParser(testFile)) {
      parser.registerFactory(new JFRExecutionSampleFactory());
      parser.registerFactory(new JFRThreadFactory());
      parser.registerFactory(new JFRThreadGroupFactory());
      parser.registerFactory(new JFRStackTraceFactory());
      parser.registerFactory(new JFRStackFrameFactory());
      parser.registerFactory(new JFRMethodFactory());
      parser.registerFactory(new JFRClassFactory());
      parser.registerFactory(new JFRClassLoaderFactory());
      parser.registerFactory(new JFRPackageFactory());
      parser.registerFactory(new JFRModuleFactory());
      parser.registerFactory(new JFRThreadStateFactory());

      parser.handle(
          JFRExecutionSample.class,
          (event, ctl) -> {
            bh.consume(event.startTime());
            eventCount.incrementAndGet();
          });
      parser.run();
    }

    bh.consume(eventCount.get());
  }

  public static void main(String[] args) throws Exception {
    org.openjdk.jmh.Main.main(args);
  }
}
